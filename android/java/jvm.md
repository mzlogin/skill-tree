# JVM

**目录**

<!-- vim-markdown-toc GFM -->
* [GC](#gc)
    * [判断对象是否存活](#判断对象是否存活)
        * [引用计数算法](#引用计数算法)
        * [可达性分析算法](#可达性分析算法)
    * [垃圾收集算法](#垃圾收集算法)
        * [标记-清除算法](#标记-清除算法)
        * [复制算法](#复制算法)
        * [标记-整理算法](#标记-整理算法)
        * [分代收集算法](#分代收集算法)
* [参考](#参考)

<!-- vim-markdown-toc -->

*本文内容主要摘抄自《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》。*

## GC

### 判断对象是否存活

#### 引用计数算法

**注：**主流的 Java 虚拟机里没有选用引用计数算法来管理内存。

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。

但是它很难解决对象之间想到循环引用的问题，即两个对象只是相互持有对方的引用，但是实际它们都不会被访问到的情况。

#### 可达性分析算法

基本思路是通过一系列的称为 GC Roots 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（即从 GC Roots 到这个对象不可达）时，则证明此对象不可用。

可作为 GC Roots 的节点主要在**全局性的引用**（例如常量或类静态属性）与**执行上下文**（如栈帧中的本地变量表）中。

在 Java 语言中，可作为 GC Roots 的对象包括下面几种：

* 虚拟机栈（栈帧中的本地变量表）中引用的对象。

* 方法区中类静态属性引用的对象。

* 方法区中常量引用的对象。

* 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。

### 垃圾收集算法

#### 标记-清除算法

首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

不足：

* 效率。

    标记和清除两个过程的效率都不高。

* 空间。

    标记清除后会产生大量不连续的内存碎片。

#### 复制算法

将内存划分为两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上，然后将已使用过的内存空间一次清理掉。

不足：

* 可用内存变少。

HotSpot 中采用 Eden:Survivor:Survivor 比例 8:1:1 来划分空间，每次新生代可用80%+10%，当 Survivor 空间不够用时，需要依赖其它内存（这里指老年代）进行分配担保（Handle Promotion）。

#### 标记-整理算法

一般用于老年代。

先标记可清理对象，然后将存活对象向一端移动，再直接清理掉端边界以外的内存。

#### 分代收集算法

根据对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代。在新生代中，采用复制算法；在老年代中，使用标记-清理或标记-整理算法。

## 参考

* 《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》
